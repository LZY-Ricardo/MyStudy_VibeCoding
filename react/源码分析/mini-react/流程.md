


          
这是一个完整的Mini React实现，包含了React Fiber架构的核心功能。让我全面讲解代码结构和实现流程：

## 1. 核心数据结构

### 全局变量
```javascript
let nextUnitOfWork = null;  // 下一个要处理的工作单元(Fiber节点)
let wipRoot = null;         // work in progress root，正在构建的Fiber树根节点
let currentRoot = null;     // 当前已渲染的Fiber树根节点
let deletions = null;       // 要删除的节点数组
```

### Fiber节点结构
每个Fiber节点包含：
- `type`: 元素类型（如'div'、函数组件等）
- `props`: 属性对象，包含children
- `dom`: 对应的DOM节点
- `return`: 父Fiber节点
- `child`: 第一个子Fiber节点
- `sibling`: 兄弟Fiber节点
- `alternate`: 上一次渲染的对应Fiber节点
- `effectTag`: 操作标记（PLACEMENT、UPDATE、DELETION）

## 2. JSX转换 - createElement函数

```javascript
function createElement(type, props, ...children) {
    return {
        type,
        props: {
            ...props,
            children: children.map(child => {
                const isTextNode = typeof child === 'string' || typeof child === "number";
                return isTextNode ? createTextNode(child) : child;
            })
        }
    };
}
```

**功能**：
- 将JSX语法转换为虚拟DOM对象
- 处理文本节点，将字符串和数字转换为TEXT_ELEMENT类型
- 构建props对象，包含所有属性和children数组

## 3. 渲染入口 - render函数

```javascript
function render(element, container) {
    wipRoot = {
        dom: container,
        props: {
            children: [element]
        },
        alternate: currentRoot
    };
    deletions = [];
    nextUnitOfWork = wipRoot;
}
```

**功能**：
- 创建Fiber树的根节点
- 初始化工作队列
- 启动渲染流程

## 4. 时间切片调度 - workLoop函数

```javascript
function workLoop(deadline) {
    let shouldYield = false;
    while (nextUnitOfWork && !shouldYield) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        shouldYield = deadline.timeRemaining() < 1;
    }
    if (!nextUnitOfWork && wipRoot) {
        commitRoot();
    }
    requestIdleCallback(workLoop);
}
```

**核心机制**：
- **可中断渲染**：每处理一个Fiber节点就检查剩余时间
- **时间切片**：当剩余时间少于1ms时主动让出控制权
- **递归调度**：使用requestIdleCallback持续处理
- **提交阶段**：所有工作完成后统一更新DOM

## 5. 工作单元处理 - performUnitOfWork函数

```javascript
function performUnitOfWork(fiber) {
    const isFunctionComponent = fiber.type instanceof Function;
    if (isFunctionComponent) {
        updateFunctionComponent(fiber);
    } else {
        updateHostComponent(fiber);
    }
    
    // 深度优先遍历
    if (fiber.child) {
        return fiber.child;
    }
    let nextFiber = fiber;
    while (nextFiber) {
        if (nextFiber.sibling) {
            return nextFiber.sibling;
        }
        nextFiber = nextFiber.return;
    }
}
```

**处理流程**：
1. **组件类型判断**：区分函数组件和宿主组件
2. **深度优先遍历**：子节点 → 兄弟节点 → 父节点的兄弟节点
3. **返回下一个工作单元**

## 6. 组件更新处理

### 宿主组件更新
```javascript
function updateHostComponent(fiber) {
    if (!fiber.dom) {
        fiber.dom = createDom(fiber);
    }
    reconcileChildren(fiber, fiber.props.children);
}
```

### 函数组件更新
```javascript
function updateFunctionComponent(fiber) {
    wipFiber = fiber;
    stateHookIndex = 0;
    wipFiber.stateHooks = [];
    wipFiber.effectHooks = [];
    
    const children = [fiber.type(fiber.props)];
    reconcileChildren(fiber, children);
}
```

## 7. DOM操作 - createDom和updateDom

### DOM创建
```javascript
function createDom(fiber) {
    const dom = fiber.type === 'TEXT_ELEMENT' ?
        document.createTextNode('') :
        document.createElement(fiber.type);
    updateDom(dom, {}, fiber.props);
    return dom;
}
```

### DOM更新
```javascript
function updateDom(dom, prevProps, newProps) {
    // 移除旧事件
    Object.keys(prevProps)
        .filter(isEvent)
        .filter(key => !(key in newProps) || isNew(prevProps, newProps)(key))
        .forEach(name => {
            const eventType = name.toLowerCase().substring(2);
            dom.removeEventListener(eventType, prevProps[name]);
        });
    
    // 移除旧属性
    Object.keys(prevProps)
        .filter(isProperty)
        .filter(isGone(prevProps, newProps))
        .forEach(name => {
            dom[name] = '';
        });
    
    // 添加新属性
    Object.keys(newProps)
        .filter(isProperty)
        .filter(isNew(prevProps, newProps))
        .forEach(name => {
            dom[name] = newProps[name];
        });
    
    // 添加新事件
    Object.keys(newProps)
        .filter(isEvent)
        .filter(isNew(prevProps, newProps))
        .forEach(name => {
            const eventType = name.toLowerCase().substring(2);
            dom.addEventListener(eventType, newProps[name]);
        });
}
```

## 8. Diff算法 - reconcileChildren

```javascript
function reconcileChildren(wipFiber, elements) {
    let index = 0;
    let oldFiber = wipFiber.alternate?.child;
    let prevSibling = null;
    
    while (index < elements.length || oldFiber != null) {
        const element = elements[index];
        let newFiber = null;
        const sameType = element?.type == oldFiber?.type;
        
        if (sameType) {
            // 更新节点
            newFiber = {
                type: oldFiber.type,
                props: element.props,
                dom: oldFiber.dom,
                return: wipFiber,
                alternate: oldFiber,
                effectTag: "UPDATE",
            };
        }
        if (element && !sameType) {
            // 新增节点
            newFiber = {
                type: element.type,
                props: element.props,
                dom: null,
                return: wipFiber,
                alternate: null,
                effectTag: "PLACEMENT",
            };
        }
        if (oldFiber && !sameType) {
            // 删除节点
            oldFiber.effectTag = "DELETION";
            deletions.push(oldFiber);
        }
        
        // 构建Fiber链表
        if (oldFiber) {
            oldFiber = oldFiber.sibling;
        }
        if (index === 0) {
            wipFiber.child = newFiber;
        } else if (element) {
            prevSibling.sibling = newFiber;
        }
        prevSibling = newFiber;
        index++;
    }
}
```

**Diff策略**：
- **类型比较**：比较新旧节点的type
- **三种操作**：UPDATE（更新）、PLACEMENT（新增）、DELETION（删除）
- **链表构建**：通过child和sibling指针构建Fiber链表

## 9. 提交阶段 - commitRoot和commitWork

```javascript
function commitRoot() {
    deletions.forEach(commitWork);
    commitWork(wipRoot.child);
    currentRoot = wipRoot;
    wipRoot = null;
    deletions = [];
}

function commitWork(fiber) {
    if (!fiber) return;
    
    let domParentFiber = fiber.return;
    while (!domParentFiber.dom) {
        domParentFiber = domParentFiber.return;
    }
    const domParent = domParentFiber.dom;
    
    if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {
        domParent.appendChild(fiber.dom);
    } else if (fiber.effectTag === "UPDATE" && fiber.dom != null) {
        updateDom(fiber.dom, fiber.alternate.props, fiber.props);
    } else if (fiber.effectTag === "DELETION") {
        commitDeletion(fiber, domParent);
    }
    
    commitWork(fiber.child);
    commitWork(fiber.sibling);
}
```

## 10. 完整执行流程

1. **JSX编译**：JSX → createElement调用 → 虚拟DOM
2. **渲染启动**：render函数创建wipRoot，设置nextUnitOfWork
3. **时间切片调度**：workLoop在浏览器空闲时处理Fiber节点
4. **工作单元处理**：performUnitOfWork处理单个Fiber节点
5. **组件更新**：根据组件类型调用相应的更新函数
6. **Diff算法**：reconcileChildren比较新旧节点，生成effectTag
7. **DOM操作准备**：createDom创建DOM节点，updateDom准备属性更新
8. **提交阶段**：commitRoot统一执行所有DOM操作
9. **状态切换**：currentRoot = wipRoot，准备下一轮渲染

## 核心优势

1. **非阻塞渲染**：时间切片避免长时间阻塞主线程
2. **可中断恢复**：支持高优先级任务中断低优先级渲染
3. **增量更新**：只更新变化的部分
4. **双缓冲机制**：wipRoot和currentRoot确保状态一致性
5. **高效Diff**：基于type的简单但有效的比较策略

这个Mini React实现展示了现代React Fiber架构的核心思想，通过链表结构和时间切片实现了高性能的并发渲染。
        