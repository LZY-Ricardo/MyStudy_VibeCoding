# node.js 基本架构


# node.js 是什么
是一个运行在操作系统上的 javascript 运行时环境, 提供了一系列操作系统的 api。

# 文章生成工具
- 输入标题
- 读取语料库
- 判断字数达标?
- 是 -- 生成文章
- 否 -- 继续在语料库中选取内容 -- 直到字数达标 -- 生成文章



# HTTP
- 标准的开发式互联网模型:
1. 物理层
2. 数据链路层
3. 网络层: IP 协议 DNS 解析
4. 传输层: TCP 协议
5. 会话层
6. 表示层
7. 应用层: HTTP 协议 (超文本传输协议)

- 使用 net 模块创建 TCP 服务, 用 TCP 服务来处理 客户端的 HTTP 请求, 需要使用字符串模板来组织 http 请求和响应报文, 很麻烦
# 使用 http 模块创建 HTTP 服务, 更简便处理 http 请求

- 为什么http 协议要分请求头和请求体?
 1. 为了内容协商 -- 根据不同的 accept 头, 返回不同的内容


# 静态文件服务



# HTTP 缓存

- 强缓存
 在响应头中添加 'Cache-Control' : 'max-age=86400'
 1. 浏览器会缓存文件, 在缓存时间内, 再次请求该文件, 浏览器会直接从缓存中读取文件, 不会向服务器请求文件.
 2. 缓存时间: 单位是秒, 表示文件在缓存中的时间, 超过缓存时间, 浏览器会向服务器请求文件. 可以通过Cache-Control 头来设置缓存时间.
 3. 通过浏览器地址栏请求的资源是无法被强缓存的

- 协商缓存
 服务端返回一个资源并设置 'last-modified' 响应头, 浏览器会在后续请求头中自动添加 'if-modified-since'请求头, 值为 'last-modified' 头的值, 服务器会根据这个头来判断资源是否有修改, 如果没有修改, 服务器会返回 304 状态码, 浏览器会从缓存中读取文件.
 1. 让浏览器 url 地址栏请求的资源也可以走缓存
 
 - 'last-modified': stat.mtimeMs 存在一个缺陷, 就是如果资源改变又撤销, 浏览器就会认为资源最后一次修改时间改变, 所以就不会走缓存了.

 - 'etag': "文件指纹": 每次资源改变, 就会改变文件指纹, 浏览器会在后续请求头中自动添加 'if-none-match' 请求头, 值为 'etag' 头的值, 服务器会根据这个头来判断资源是否有修改, 如果没有修改, 服务器会返回 304 状态码, 浏览器会从缓存中读取文件.

# 文件名修改
- 服务端的图片都命名为 logo.xxxx.png 其中 xxxxx 是文件的哈希值 相当于文件的指纹


# 文件压缩
